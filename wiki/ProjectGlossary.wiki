#summary Some of the terms used in this project.
#labels Featured,Phase-Design,Phase-Implementation,Phase-Use

=== Binding ===

An object which represents a method from a particular instance. Invoking the binding is equivalent to invoking said method on the particular instance. This binding may then be stored and invoked when necessary.

=== Conversion ===

The act of taking an object of a specific type and using the information within to obtain a new object of a different type.

=== Converter ===

A [#Binding binding] which demonstrably holds a [#Converter_method converter method]. [#Converter Converters] can be registered in a [#Transmuter transmuter], which, on performing a [#Conversion conversion], will attempt to find the converter of the most appropriate [#Converter_type type] to do it.

=== Converter method ===

A method which can be used by the [#Transmuter transmuter] to perform a [#Conversion conversion]. This method must be invokable using reflection, and must have an extractable [#Converter_type converter type], so converter methods must:

  * be public
  * take a single parameter
  * not return `void`

=== Converter provider ===

An object (usually implementing [http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html Iterable]) which makes several converters available.

=== Converter type ===

A pair of [#Type_token type tokens] representing the input type and the output type accepted by the [#Converter converter].

=== Transmuter ===

The main object in the library. Registers [#Converter converters] (using their [#Converter_type type] as a key) and offers a `convert` operation, which attempts to perform the [#Conversion conversion] of a given object to a given type using the most appropriate [#Converter converter] registered.

=== Type token ===

An object used to represent Java types which is also usable with generics. Java's native reflection mechanisms are clumsy when representing generic types such as `List<? extends String>[]` and `Map<Long, Object>`, and don't take advantage of the compiler's generic inference. 

To obtain the complex types above, a common technique is to use type tokens, e.g.

{{{
// note the anonymous subclass creation: it's necessary!
Type arrayOflistOfSomethingThatExtendsString = new TypeToken<List<? extends String>[]>() {}.getType();
}}}

The problem with the raw `Type` instance above is that there's no compile-time generic information for it; one could not use the created type with a generic method such as

{{{
// can't make a class of List<? extends String>[]...
public <T> T method(Class<T> cls) { 
  //...
}
}}}

One would need a method like

{{{
// it works, but casting is needed for the result
public Object method(Type type) {
  //...
}
}}}

But, if one wants to represent a complex type and still retain generics' benefits, one could use the type token directly:

{{{
// ...but we can make a type token of List<? extends String>[]!
public <T> T method(TypeToken<T> token) { 
  //...
}
}}}

which is done in this library.